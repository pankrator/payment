// Code generated by counterfeiter. DO NOT EDIT.
package storagefakes

import (
	"database/sql"
	"sync"

	"github.com/pankrator/payment/model"
	"github.com/pankrator/payment/query"
	"github.com/pankrator/payment/storage"
)

type FakeStorage struct {
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CountStub        func(string, string, ...interface{}) (int, error)
	countMutex       sync.RWMutex
	countArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	countReturns struct {
		result1 int
		result2 error
	}
	countReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	CreateStub        func(model.Object) (model.Object, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 model.Object
	}
	createReturns struct {
		result1 model.Object
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 model.Object
		result2 error
	}
	DeleteStub        func(string, string, ...interface{}) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAllStub        func(string) error
	deleteAllMutex       sync.RWMutex
	deleteAllArgsForCall []struct {
		arg1 string
	}
	deleteAllReturns struct {
		result1 error
	}
	deleteAllReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string, string) (model.Object, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getReturns struct {
		result1 model.Object
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 model.Object
		result2 error
	}
	GetByStub        func(string, string, ...interface{}) (model.Object, error)
	getByMutex       sync.RWMutex
	getByArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	getByReturns struct {
		result1 model.Object
		result2 error
	}
	getByReturnsOnCall map[int]struct {
		result1 model.Object
		result2 error
	}
	ListStub        func(string, ...query.Query) ([]model.Object, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 string
		arg2 []query.Query
	}
	listReturns struct {
		result1 []model.Object
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []model.Object
		result2 error
	}
	OpenStub        func(func(string, string) (*sql.DB, error)) error
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 func(string, string) (*sql.DB, error)
	}
	openReturns struct {
		result1 error
	}
	openReturnsOnCall map[int]struct {
		result1 error
	}
	SaveStub        func(model.Object) error
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
		arg1 model.Object
	}
	saveReturns struct {
		result1 error
	}
	saveReturnsOnCall map[int]struct {
		result1 error
	}
	TransactionStub        func(func(s storage.Storage) error) error
	transactionMutex       sync.RWMutex
	transactionArgsForCall []struct {
		arg1 func(s storage.Storage) error
	}
	transactionReturns struct {
		result1 error
	}
	transactionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeStorage) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeStorage) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeStorage) Count(arg1 string, arg2 string, arg3 ...interface{}) (int, error) {
	fake.countMutex.Lock()
	ret, specificReturn := fake.countReturnsOnCall[len(fake.countArgsForCall)]
	fake.countArgsForCall = append(fake.countArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Count", []interface{}{arg1, arg2, arg3})
	fake.countMutex.Unlock()
	if fake.CountStub != nil {
		return fake.CountStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.countReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeStorage) CountCalls(stub func(string, string, ...interface{}) (int, error)) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = stub
}

func (fake *FakeStorage) CountArgsForCall(i int) (string, string, []interface{}) {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	argsForCall := fake.countArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) CountReturns(result1 int, result2 error) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) CountReturnsOnCall(i int, result1 int, result2 error) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	if fake.countReturnsOnCall == nil {
		fake.countReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.countReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Create(arg1 model.Object) (model.Object, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 model.Object
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeStorage) CreateCalls(stub func(model.Object) (model.Object, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeStorage) CreateArgsForCall(i int) model.Object {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) CreateReturns(result1 model.Object, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) CreateReturnsOnCall(i int, result1 model.Object, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 model.Object
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Delete(arg1 string, arg2 string, arg3 ...interface{}) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStorage) DeleteCalls(stub func(string, string, ...interface{}) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeStorage) DeleteArgsForCall(i int) (string, string, []interface{}) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteAll(arg1 string) error {
	fake.deleteAllMutex.Lock()
	ret, specificReturn := fake.deleteAllReturnsOnCall[len(fake.deleteAllArgsForCall)]
	fake.deleteAllArgsForCall = append(fake.deleteAllArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteAll", []interface{}{arg1})
	fake.deleteAllMutex.Unlock()
	if fake.DeleteAllStub != nil {
		return fake.DeleteAllStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteAllReturns
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteAllCallCount() int {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	return len(fake.deleteAllArgsForCall)
}

func (fake *FakeStorage) DeleteAllCalls(stub func(string) error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = stub
}

func (fake *FakeStorage) DeleteAllArgsForCall(i int) string {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	argsForCall := fake.deleteAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteAllReturns(result1 error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = nil
	fake.deleteAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteAllReturnsOnCall(i int, result1 error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = nil
	if fake.deleteAllReturnsOnCall == nil {
		fake.deleteAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Get(arg1 string, arg2 string) (model.Object, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeStorage) GetCalls(stub func(string, string) (model.Object, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeStorage) GetArgsForCall(i int) (string, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetReturns(result1 model.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetReturnsOnCall(i int, result1 model.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 model.Object
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetBy(arg1 string, arg2 string, arg3 ...interface{}) (model.Object, error) {
	fake.getByMutex.Lock()
	ret, specificReturn := fake.getByReturnsOnCall[len(fake.getByArgsForCall)]
	fake.getByArgsForCall = append(fake.getByArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBy", []interface{}{arg1, arg2, arg3})
	fake.getByMutex.Unlock()
	if fake.GetByStub != nil {
		return fake.GetByStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetByCallCount() int {
	fake.getByMutex.RLock()
	defer fake.getByMutex.RUnlock()
	return len(fake.getByArgsForCall)
}

func (fake *FakeStorage) GetByCalls(stub func(string, string, ...interface{}) (model.Object, error)) {
	fake.getByMutex.Lock()
	defer fake.getByMutex.Unlock()
	fake.GetByStub = stub
}

func (fake *FakeStorage) GetByArgsForCall(i int) (string, string, []interface{}) {
	fake.getByMutex.RLock()
	defer fake.getByMutex.RUnlock()
	argsForCall := fake.getByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) GetByReturns(result1 model.Object, result2 error) {
	fake.getByMutex.Lock()
	defer fake.getByMutex.Unlock()
	fake.GetByStub = nil
	fake.getByReturns = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetByReturnsOnCall(i int, result1 model.Object, result2 error) {
	fake.getByMutex.Lock()
	defer fake.getByMutex.Unlock()
	fake.GetByStub = nil
	if fake.getByReturnsOnCall == nil {
		fake.getByReturnsOnCall = make(map[int]struct {
			result1 model.Object
			result2 error
		})
	}
	fake.getByReturnsOnCall[i] = struct {
		result1 model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) List(arg1 string, arg2 ...query.Query) ([]model.Object, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 string
		arg2 []query.Query
	}{arg1, arg2})
	fake.recordInvocation("List", []interface{}{arg1, arg2})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeStorage) ListCalls(stub func(string, ...query.Query) ([]model.Object, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeStorage) ListArgsForCall(i int) (string, []query.Query) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) ListReturns(result1 []model.Object, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListReturnsOnCall(i int, result1 []model.Object, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []model.Object
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []model.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Open(arg1 func(string, string) (*sql.DB, error)) error {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 func(string, string) (*sql.DB, error)
	}{arg1})
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.openReturns
	return fakeReturns.result1
}

func (fake *FakeStorage) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeStorage) OpenCalls(stub func(func(string, string) (*sql.DB, error)) error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeStorage) OpenArgsForCall(i int) func(string, string) (*sql.DB, error) {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) OpenReturns(result1 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) OpenReturnsOnCall(i int, result1 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Save(arg1 model.Object) error {
	fake.saveMutex.Lock()
	ret, specificReturn := fake.saveReturnsOnCall[len(fake.saveArgsForCall)]
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
		arg1 model.Object
	}{arg1})
	fake.recordInvocation("Save", []interface{}{arg1})
	fake.saveMutex.Unlock()
	if fake.SaveStub != nil {
		return fake.SaveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveReturns
	return fakeReturns.result1
}

func (fake *FakeStorage) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *FakeStorage) SaveCalls(stub func(model.Object) error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = stub
}

func (fake *FakeStorage) SaveArgsForCall(i int) model.Object {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	argsForCall := fake.saveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) SaveReturns(result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SaveReturnsOnCall(i int, result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	if fake.saveReturnsOnCall == nil {
		fake.saveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Transaction(arg1 func(s storage.Storage) error) error {
	fake.transactionMutex.Lock()
	ret, specificReturn := fake.transactionReturnsOnCall[len(fake.transactionArgsForCall)]
	fake.transactionArgsForCall = append(fake.transactionArgsForCall, struct {
		arg1 func(s storage.Storage) error
	}{arg1})
	fake.recordInvocation("Transaction", []interface{}{arg1})
	fake.transactionMutex.Unlock()
	if fake.TransactionStub != nil {
		return fake.TransactionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.transactionReturns
	return fakeReturns.result1
}

func (fake *FakeStorage) TransactionCallCount() int {
	fake.transactionMutex.RLock()
	defer fake.transactionMutex.RUnlock()
	return len(fake.transactionArgsForCall)
}

func (fake *FakeStorage) TransactionCalls(stub func(func(s storage.Storage) error) error) {
	fake.transactionMutex.Lock()
	defer fake.transactionMutex.Unlock()
	fake.TransactionStub = stub
}

func (fake *FakeStorage) TransactionArgsForCall(i int) func(s storage.Storage) error {
	fake.transactionMutex.RLock()
	defer fake.transactionMutex.RUnlock()
	argsForCall := fake.transactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) TransactionReturns(result1 error) {
	fake.transactionMutex.Lock()
	defer fake.transactionMutex.Unlock()
	fake.TransactionStub = nil
	fake.transactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) TransactionReturnsOnCall(i int, result1 error) {
	fake.transactionMutex.Lock()
	defer fake.transactionMutex.Unlock()
	fake.TransactionStub = nil
	if fake.transactionReturnsOnCall == nil {
		fake.transactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getByMutex.RLock()
	defer fake.getByMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	fake.transactionMutex.RLock()
	defer fake.transactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storage.Storage = new(FakeStorage)
